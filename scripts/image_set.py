#A set of routines for processing the images.txt file generated by colmap
import numpy as np
from scipy.spatial.transform import Rotation as R
import pdb
from points_from_depth import read_image_csv
# def read_depthP_csv(fName):
#     with open(fName,"r") as fin:
#         A=fin.readlines()

#     all_images={}
#     for ln_ in A:        
#         if len(ln_)<2 or '#' in ln_:
#             continue
#         if ln_[-1]=='\n':
#             ln_=ln_[:-1]
#         pdb.set_trace()
#         ln_s=ln_.split(', ')
#         # Should be of format:
#         #   image, PX, PY, PZ, QX, QY, QZ, QW, CenterPX, CenterPY, CenterPZ
#         name=ln_s[0]
#         id_str=name.split('_')[1].split('.')[0]
#         id=int(id_str)
#         world_pose=np.array([float(ln_s[1]),float(ln_s[2]),float(ln_s[3])])
#         quat=[float(ln_s[4]),float(ln_s[5]),float(ln_s[6]),float(ln_s[7])]
#         rotM=np.identity(4)
#         rotM[:3,:3]=R.from_quat(quat).as_matrix()
#         rotM[:3,3]=world_pose
#         center_pose=np.array([float(ln_s[8]),float(ln_s[9]),float(ln_s[10])])
#         all_images[name]={'id': id, 'global_pose': world_pose, 'global_poseM': rotM, 'name': name, 'center_pose': center_pose}
#     return all_images

def dist(A:np.array):
    return np.sqrt(np.power(A,2).sum())

class image_set():
    def __init__(self, images_csv:str):
        self.all_images = read_image_csv(images_csv)

    def get_pose_by_name(self, key):
        if key in self.all_images:
            return self.all_images[key]['center_pose']
        return None

    def get_pose_by_id(self, id):
        for key in self.all_images.keys():
            if self.all_images[key]['id']==id:
                return self.all_images[key]['center_pose']
        return None

    def get_related_poses(self, tgt_obj_pose:np.array, max_dist:float=1, max_angle:float=0.5):
        im_list=[]
        for key in self.all_images.keys():
            im = self.all_images[key]
            # Filter Images by Distance from Target
            deltaD=dist(tgt_obj_pose-im['center_pose'])
            if deltaD>max_dist:
                continue

            forward=im['center_pose']-im['global_pose']
            actual=tgt_obj_pose-im['global_pose']
            angle=np.arccos(np.dot(forward,actual)/(dist(forward)*dist(actual)))
            if np.fabs(angle)<max_angle:
                im_list.append(key)

        return im_list
    
    def get_all_poses(self):
        arr = []
        for key in self.all_images.keys():
            arr.append(self.all_images[key]['global_pose'])
        return np.array(arr)
    
    def get_nearest_pose_by_angle(self, tgt_obj_pose: np.array, tgt_camera_poseM):
        # First - get a list of all poses that look at the target
        im_list = self.get_related_poses(tgt_obj_pose)
        
        # Second - find the pose with the closest camera angle in global coordinates
        forward=np.array([0,0,1.0],dtype=float)
        tgt_vec=np.matmul(tgt_camera_poseM[:3,:3], forward)
        dTgt=dist(tgt_vec)
        best_angle=np.pi
        best_key = None
        for key in im_list:
            im_vec=np.matmul(self.all_images['global_poseM'][key][:3,:3],forward)
            im_angle=np.arccos(np.dot(tgt_vec,im_vec)/(dTgt*dist(im_vec)))
            if np.abs(im_angle)<best_angle:
                best_key=key
                best_angle=np.abs(im_angle)
        
        return best_key


